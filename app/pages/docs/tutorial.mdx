---
title: Tutoriel
sidebar_label: Tutoriel
---

Dans ce tutoriel, nous allons vous apprendre √† cr√©er use simple
application de vote.

Ce guide suppose que vous avez d√©j√† [install√© Blitz](./get-started). Vous
pouvez v√©rifier si c'est le cas ainsi que quelle version vous avez en
ex√©cutant la commande suivante dans votre terminal :

```sh
blitz -v
```

Si Blitz est bien install√©, vous devriez voir le num√©ro de la version de
votre installation. Sinon il ne l'est pas, vous devriez voir une erreur
comme "command not found: blitz".

## Cr√©ez une nouvelle application {#creating-a-new-app}

Depuis le terminal, d√©placez-vous dans le r√©pertoire o√π vous souhaitez
cr√©er votre application en utilisant la commande `cd`. Ensuite, ex√©cutez
la commande suivante :

```sh
blitz new mon-appli-blitz
```

Blitz s'occupera de cr√©er un dossier `mon-appli-blitz` dans le r√©pertoire.
Il vous sera √©galement demand√© de choisir un module de gestion de
formulaire. Pour les exemples suivant, choisissez le module recommand√©
`React Final Form`.

Jettons un oeil √† ce que `blitz new` a cr√©√© :

```
mon-appli-blitz/
‚îú‚îÄ‚îÄ app/
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ api/
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ auth/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ components/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ LoginForm.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ SignupForm.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ mutations/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ changePassword.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ forgotPassword.test.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ forgotPassword.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ login.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ logout.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ resetPassword.test.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ resetPassword.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ signup.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ pages/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ forgot-password.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ login.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ reset-password.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ signup.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ validations.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ core/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ components/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ Form.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ LabeledTextField.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ hooks/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ useCurrentUser.ts
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ layouts/
‚îÇ¬†¬† ‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ Layout.tsx
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ pages/
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ 404.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ _app.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ _document.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.test.tsx
‚îÇ¬†¬† ‚îÇ¬†¬† ‚îî‚îÄ‚îÄ index.tsx
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ users/
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ queries/
‚îÇ¬†¬†         ‚îî‚îÄ‚îÄ getCurrentUser.ts
‚îú‚îÄ‚îÄ db/
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ index.ts
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ schema.prisma
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ seeds.ts
‚îú‚îÄ‚îÄ integrations/
‚îú‚îÄ‚îÄ mailers/
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ forgotPasswordMailer.ts
‚îú‚îÄ‚îÄ public/
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ favicon.ico*
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ logo.png
‚îú‚îÄ‚îÄ test/
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ setup.ts
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ utils.tsx
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ babel.config.js
‚îú‚îÄ‚îÄ blitz.config.js
‚îú‚îÄ‚îÄ jest.config.js
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ tsconfig.json
‚îú‚îÄ‚îÄ types.d.ts
‚îú‚îÄ‚îÄ types.ts
‚îî‚îÄ‚îÄ yarn.lock
```

Ces fichiers sont :

- Le r√©pertoire `app/` contient la majorit√© de votre projet. C'est ici que
  vous ajouterez vos pages et routes d'API.

- Le r√©pertoire `app/pages/` est le principal endroit ou vous cr√©erez vos
  pages. Si vous avez d√©j√† utilis√© Next.js, vous remarquerez imm√©diatement
  la diff√©rence. Avec Blitz, vous pouvez avoir plusieurs r√©pertoires
  `pages` qui seront combin√©s au moment de la compilation.

- Le r√©pertoire `app/core/` est l'endroit parfait pour stocker vos
  composants, hooks et autre code r√©utilisable √† travers votre
  application.

- Le r√©pertoire `db/` contient la configuration de votre base de donn√©es.
  Si vous voulez cr√©er un nouveau mod√®le ou lancer une migration, c'est
  ici que vous trouverez ce qu'il vous faut.

- Le r√©pertoire `public/` contient toutes vos resources statiques. Si
  votre application n√©c√©ssite des images, documents ou vid√©os, c'est ici
  que vous devriez les stocker.

- Les fichiers `.babelrc.js`, `.env`, etc. aussi connus sous le nom de
  "dotfiles", sont des fichiers de configuration pour diff√©rents outils
  JavaScript.

- `blitz.config.js` offre aux utilisateurs avanc√©s la possibilit√© de
  personnaliser leur installation de Blitz. Il supporte le m√™me format que
  `next.config.js`.

- `tsconfig.json` contient nos r√®gles de configuration pr√©f√©r√©es pour le
  compilateur TypeScript.

## D√©marrez le serveur de d√©veloppement {#the-development-server}

Assurez-vous d'√™tre dans le r√©pertoire `mon-appli-blitz` avant d'ex√©cuter
la commande suivante :

```sh
blitz dev
```

Vous devriez voir le message suivant dans votre terminal :

```sh
‚úî Compiled
Loaded env from /private/tmp/mon-appli-blitz/.env
warn  - You have enabled experimental feature(s).
warn  - Experimental features are not covered by semver, and may cause unexpected or broken application behavior. Use them at your own risk.

ready - started server on 0.0.0.0:3000, url: http://localhost:3000
info  - Using external babel configuration from /mon-appli-blitz/babel.config.js
event - compiled successfully
```

Maintenant que le serveur est d√©marr√©, visitez
[localhost:3000](http://localhost:3000) avec votre navigateur web. Vous
verrez une page de bienvenue avec le logo Blitz. Tout fonctionne!

## Cr√©ez un compte utilisateur {#sign-up-as-a-user}

Les applications Blitz comprennent un syst√®me de gestion d'utilisateurs
par d√©faut, essayons le! Cliquez sur le bouton **Sign Up**. Entrez
n'importe quelle adresse email et mot de passe et cliquez sur **Create
Account**. Vous serez ensuite redirig√© vers la page d'acceuil o√π vous
pourrez apercevoir votre `id` et votre `role`.

Si vous le d√©sirez, vous pouvez √©galement essayer de vous d√©connecter et
vous connecter de nouveau. N'h√©sitez pas √† cliquer sur **Forgot your
password?** pour r√©initialiser votre mot de passe.

## Construisez votre premi√®re page {#write-your-first-page}

Ouvrez le fichier `app/pages/index.tsx` et remplacez le contenu du
composant `Home` par ceci :

```tsx
//...

const Home: BlitzPage = () => {
  return (
    <div>
      <h1>Bonjour, Blitz!</h1>

      <Suspense fallback="Chargement...">
        <UserInfo />
      </Suspense>
    </div>
  )
}

//...
```

Sauvegardez vos changements et vous devriez voir la page se mettre √† jour
dans votre navigateur web. Vous pouvez personnaliser ce composant autant
que vous le souhaitez. Lorsque vous serez pr√™t¬∑e, passez √† la prochaine
section.

## Configurez une base de donn√©es {#database-setup}

Bonne nouvelle! Une base de donn√©es SQLite est d√©j√† configur√©e! Vous
pouvez ex√©cuter `blitz prisma studio` dans votre terminal pour explorer
vos tables et leurs champs via une interface web.

Veuillez notez que dans le contexte d'un vrai projet, vous auriez avantage
√† utiliser une base de donn√©es plus robuste, telle que PostgreSQL, d√®s le
d√©part afin d'√©viter de devoir changer plus tard. Pour plus
d'informations, visitez notre
[guide de base de donn√©es](database-overview). Pour ce tutoriel, nous
allons continuer avec SQLite.

## G√©n√©rez le code de vos mod√®les {#scaffolding-code-for-our-models}

Blitz vous permet de g√©n√©rer le code n√©c√©ssaire pour une multitude de
situations via la commande [`generate`](./cli-generate). Nous allons
l'utiliser afin de g√©n√©rer deux mod√®les : `Question` et `Choice`. Une
`Question` consiste du texte de la question ainsi qu'une liste de choix de
r√©ponse. Un `Choice` contient le texte du choice, un nombre de votes et la
question √† laquelle il fait r√©f√©rence. Blitz s'occupe de g√©n√©rer un `id`
unique, la date de cr√©ation ainsi que la date de la derni√®re modification
pour chacun des mod√®le.

#### Premi√®rement, nous allons g√©n√©rer le mod√®le `Question` :

```sh
blitz generate all question texte:string
```

Lorsque demand√©, appuyez sur la touche **Entr√©e** afin d'ex√©cuter
`prisma migrate` pour mettre votre schema de base de donn√©es √† jour avec
le mod√®le nouvellement cr√©√©. Vous devrez entrer un nom pour cette
migration, par exemple : "ajout question".

```
CREATE    app/pages/questions/[questionId].tsx
CREATE    app/pages/questions/[questionId]/edit.tsx
CREATE    app/pages/questions/index.tsx
CREATE    app/pages/questions/new.tsx
‚úî Compiled
CREATE    app/questions/components/QuestionForm.tsx
CREATE    app/questions/queries/getQuestion.ts
CREATE    app/questions/queries/getQuestions.ts
CREATE    app/questions/mutations/createQuestion.ts
CREATE    app/questions/mutations/deleteQuestion.ts
CREATE    app/questions/mutations/updateQuestion.ts

‚úî Model 'Question' created in schema.prisma:

>
> model Question {
>   id        Int      @id @default(autoincrement())
>   createdAt DateTime @default(now())
>   updatedAt DateTime @updatedAt
>   texte     String
> }
>

‚úî Run 'prisma migrate dev' to update your database? (Y/n) ¬∑ true
Environment variables loaded from .env
Prisma schema loaded from db/schema.prisma
Datasource "db": SQLite database "db.sqlite" at "file:./db.sqlite"

‚úî Enter a name for the new migration: ‚Ä¶ ajout question
The following migration(s) have been created and applied from new schema changes:

migrations/
  ‚îî‚îÄ 20210722070215_ajout_question/
    ‚îî‚îÄ migration.sql

Your database is now in sync with your schema.

‚úî Generated Prisma Client (2.27.0) to ./node_modules/@prisma/client in 187ms
```

Lorsque suivie par l'option `all`, la commande `generate` g√©n√®re un mod√®le
ainsi que toutes ses requ√™tes, mutations et pages. Pour une liste
d'options compl√®te, visitez [Blitz generate](./cli-generate).

#### Ensuite g√©n√©r√©z le mod√®le `Choice` avec ses requ√™tes et mutations.

Cette fois, nous allons utiliser l'option `resource` puisque nous ne
voulons pas g√©n√©rer de pages pour le mod√®le `Choice`:

```sh
blitz generate resource choice texte votes:int:default=0 belongsTo:question
```

Si vous obtenez une erreur, ex√©cutez `blitz prisma format`

Veuillez noter que ceci ne requiert pas de migration puisque nous n'avons
pas encore ajout√© le champ `Choix` au mod√®le `Question`. Nous allons donc
choisir `false` lorsqu'on nous demandera de d√©marrer une migration :

```
CREATE    app/choices/queries/getChoice.ts
CREATE    app/choices/queries/getChoices.ts
CREATE    app/choices/mutations/createChoice.ts
CREATE    app/choices/mutations/deleteChoice.ts
CREATE    app/choices/mutations/updateChoice.ts

‚úî Model for 'choice' created in schema.prisma:

> model Choice {
>   id         Int      @default(autoincrement()) @id
>   createdAt  DateTime @default(now())
>   updatedAt  DateTime @updatedAt
>   texte      String
>   votes      Int      @default(0)
>   question   Question @relation(fields: [questionId], references: [id])
>   questionId Int
> }

? Run 'prisma migrate dev' to update your database? (Y/n) ‚Ä∫ false
```

#### Finalement, ajoutez une relation vers `Choice` √† `Question`.

Ouvrez `db/schema.prisma` et ajoutez `choix Choice[]` au mod√®le
`Question`.

```diff
model Question {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  texte     String
+ choix     Choice[]
}
```

Nous pouvons d√©sormais d√©marrer la migration pour mettre √† jour notre base
de donn√©es :

```sh
blitz prisma migrate dev
```

Encore une fois, choisissez un nom pour la migration, par exemple : "ajout
choice".

```
Environment variables loaded from .env
Prisma schema loaded from db/schema.prisma
Datasource "db": SQLite database "db.sqlite" at "file:./db.sqlite"

‚úî Name of migration ‚Ä¶ ajout choice
The following migration(s) have been created and applied from new schema changes:

migrations/
  ‚îî‚îÄ 20210412175528_ajout_choice/
    ‚îî‚îÄ migration.sql

Your database is now in sync with your schema.
```

Notre base de donn√©es est maintenant pr√™te √† √™tre utilis√©e et un client
Prisma a √©galement √©t√© g√©n√©r√© pour nous. Allons l'essayer!

## Explorez le client de base de donn√©es Prisma {#playing-with-the-prisma-database-client}

Maintenant, utilisons la console interactive Blitz pour essayer le client
Prisma fournit par Blitz. Pour d√©buter, ex√©cutez cette commande :

```sh
blitz console
```

Lorsque c'est fait, essayez le client de base de donn√©es :

```sh
# Aucune Question n'a √©t√© cr√©√©e pour l'instant :
‚ö° > await db.question.findMany()
[]

# Cr√©ez une nouvelle Question :
‚ö° > let q = await db.question.create({data: {texte: "Quoi de neuf?"}})
undefined

# Observer l'objet entier :
‚ö° > q
{
  id: 1,
  createdAt: 2020-06-15T15:06:14.959Z,
  updatedAt: 2020-06-15T15:06:14.959Z,
  texte: "Quoi de neuf?"
}

# Ou acc√©dez √† une propri√©t√© individuelle de l'objet :
‚ö° > q.texte
"Quoi de neuf?"

# Modifiez des valeurs en utilisant la fonction de mise √† jour (update):
‚ö° > q = await db.question.update({where: {id: 1}, data: {texte: "√áa va?"}})
{
  id: 1,
  createdAt: 2020-06-15T15:06:14.959Z,
  updatedAt: 2020-06-15T15:13:17.394Z,
  texte: "√áa va?"
}

# db.question.findMany() affiche maintenant toutes les questions enregistr√©es :
‚ö° > await db.question.findMany()
[
  {
    id: 1,
    createdAt: 2020-06-15T15:06:14.959Z,
    updatedAt: 2020-06-15T15:13:17.394Z,
    texte: "√áa va?"
  }
]
```

## Modifiez le code g√©n√©r√© pour nos attributs de mod√®les {#update-generated-code-for-our-model-attributes}

<Card type="info">

Avant de d√©marrer l'application de nouveau, nous devons personnaliser une
partie du code qui a √©t√© g√©n√©r√© pour nous. Dans une version future, ces
changements ne seront pas n√©c√©ssaires mais pour l'instant ils sont requis
afin de r√©gler quelques bogues.

</Card>

Le contenu des pages g√©n√©r√©es ne prend pas en compte les attributs d√©finis
lors de la cr√©ation des mod√®les. Ce sera le cas bient√¥t, mais en
attendant, corrigeons le tout.

### Pages de Question {#question-pages}

[//]:
  #
  "Remove the following section once `generate` uses actual model attributes"

Ouvrez maintenant `app/pages/questions/index.tsx`. Vous remarquerez que le
composant `QuestionsList` √† √©t√© g√©n√©r√© dans une √©tape pr√©c√©dente :

```tsx
// app/pages/questions/index.tsx

export const QuestionsList = () => {
  const router = useRouter()
  const page = Number(router.query.page) || 0
  const [{ questions, hasMore }, { isPreviousData }] = usePaginatedQuery(
    getQuestions,
    {
      orderBy: { id: "asc" },
      skip: ITEMS_PER_PAGE * page,
      take: ITEMS_PER_PAGE,
    }
  )

  const goToPreviousPage = () =>
    router.push({ query: { page: page - 1 } })

  const goToNextPage = () => {
    if (!isPreviousData && hasMore) {
      router.push({ query: { page: page + 1 } })
    }
  }

  return (
    <div>
      <ul>
        {questions.map((question) => (
          <li key={question.id}>
            <Link href={`/questions/${question.id}`}>
              <a>{question.name}</a>
            </Link>
          </li>
        ))}
      </ul>

      <button disabled={page === 0} onClick={goToPreviousPage}>
        Previous
      </button>
      <button
        disabled={isPreviousData || !hasMore}
        onClick={goToNextPage}
      >
        Next
      </button>
    </div>
  )
}
```

Comme vous pouvez le voir, il ne fonctionnera pas puisqu'il utilise
l'attribut `name` de `Question` mais ce champ n'existe pas! Nous devons
remplacer `question.name` par `question.texte`.

```diff
// app/pages/questions/index.tsx

export const QuestionsList = () => {
  const router = useRouter()
  const page = Number(router.query.page) || 0
  const [{questions, hasMore}, {isPreviousData}] = usePaginatedQuery(
    getQuestions, {
      orderBy: {id: "asc"},
      skip: ITEMS_PER_PAGE * page,
      take: ITEMS_PER_PAGE,
    },
  )

  const goToPreviousPage = () => router.push({query: {page: page - 1}})

  const goToNextPage = () => {
    if (!isPreviousData && hasMore) {
      router.push({query: {page: page + 1}})
    }
  }

  return (
    <div>
      <ul>
        {questions.map((question) => (
          <li key={question.id}>
            <Link href={`/questions/${question.id}`}>
-              <a>{question.name}</a>
+              <a>{question.texte}</a>
            </Link>
          </li>
        ))}
      </ul>

      <button disabled={page === 0} onClick={goToPreviousPage}>
        Previous
      </button>
      <button disabled={isPreviousData || !hasMore} onClick={goToNextPage}>
        Next
      </button>
    </div>
  )
}
```

Ensuite, faisons la m√™me chose dans
`app/questions/components/QuestionForm.tsx`. Dans le formulaire de
soumission, remplacez la valeur `name` de `LabeledTextField` par
`"texte"`.

```diff
export function QuestionForm<S extends z.ZodType<any, any>>(
  props: FormProps<S>,
) {
  return (
    <Form<S> {...props}>
-     <LabeledTextField name="name" label="Name" placeholder="Name" />
+     <LabeledTextField name="texte" label="Texte" placeholder="Texte" />
    </Form>
  )
}
```

### La mutation `createQuestion` {#create-question-mutation}

Dans `app/questions/mutations/createQuestion.ts`, nous devons modifier le
schema de validation zod de `CreateQuestion` afin qu'il utilise `texte`
plut√¥t que `name`.

```diff
// app/questions/mutations/createQuestion.ts

const CreateQuestion = z
  .object({
-   name: z.string(),
+   texte: z.string(),
  })
// ...
```

### La mutation `updateQuestion` {#update-question-mutation}

Dans `app/questions/mutations/updateQuestion.ts`, nous devons modifier le
schema de validation zod de `CreateQuestion` afin qu'il utilise `texte`
plut√¥t que `name`.

```diff
// app/questions/mutations/updateQuestion.ts

const UpdateQuestion = z
  .object({
    id: z.number(),
-   name: z.string(),
+   texte: z.string(),
  })
```

### La mutation `deleteQuestion` {#delete-question-mutation}

[//]: # "Remove this section once Prisma supports cascading deletes"

Pour le moment Prisma ne nous permet pas de supprimer des donn√©es en
cascade. Dans le cadre de ce tutoriel, cela veut dire que lorsque nous
supprimons une question, les choix associ√©s √† cette question ne seront pas
supprim√©s automatiquement. Nous devons temporairement modifier la mutation
`deleteQuestion` afin d'ajouter cette fonctionnalit√© manuellement.
Naviguez vers `app/questions/mutations/deleteQuestion.ts` dans votre
√©diteur de texte et ajoutez ce qui suit au d√©but de la fonction :

```ts
await db.choice.deleteMany({ where: { questionId: id } })
```

Le r√©sultat final devrait ressembler √† ceci :

```diff
// app/questions/mutations/deleteQuestion.ts

export default resolver.pipe(
  resolver.zod(DeleteQuestion),
  resolver.authorize(),
  async ({id}) => {
+   await db.choice.deleteMany({where: {questionId: id}})
    const question = await db.question.deleteMany({where: {id}})

    return question
  },
)
```

Cette mutation va d√©sormais supprimer les choix associ√©s √† la question
avant m√™me de supprimer la question.

#### Essayez de cr√©er, modifier et supprimer des questions

Parfait! Assurez-vous que votre application est d√©marr√©e. Si ce n'est pas
le cas, ex√©cutez `blitz dev` dans votre terminal et visitez
`localhost:3000/questions`. Essayez de cr√©er quelques questions, de les
modifier et de les supprimer.

## Ajoutez des choix au formulaire de cr√©ation de question {#adding-choices-to-the-question-form}

Vous vous d√©brouillez bien jusqu'ici! Nous avons maintenant besoin
d'ajouter des choix √† nos questions. Naviguez vers
`app/questions/components/QuestionForm.tsx` dans votre √©diteur.

Ajoutez trois composants `<LabeledTextField>` au formulaire, un pour
chaque choix.

```diff
export function QuestionForm<S extends z.ZodType<any, any>>(
  props: FormProps<S>,
) {
  return (
    <Form<S> {...props}>
      <LabeledTextField name="texte" label="Texte" placeholder="Texte" />
+     <LabeledTextField name="choix.0.texte" label="Choix 1" />
+     <LabeledTextField name="choix.1.texte" label="Choix 2" />
+     <LabeledTextField name="choix.2.texte" label="Choix 3" />
    </Form>
  )
}
```

Naviguez vers `app/questions/mutations/createQuestion.ts` et modifiez le
schema zod afin qu'il accepte ces nouveaux choix. Nous devons √©galement
modifier l'appel √† la fonction `db.question.create()` pour cr√©er ces
choix. Ensuite, nous devons exporter le schema zod de `CreateQuestion`
puisque nous en aurons besoin dans la prochaine √©tape pour notre
`QuestionForm`.

```diff
// app/questions/mutations/createQuestion.ts

+ export const CreateQuestion = z
    .object({
      texte: z.string().nonempty({message: "Veuillez entrer une question."}),
+     choix: z.array(z.object({texte: z.string()})),
    })

export default resolver.pipe(
  resolver.zod(CreateQuestion),
  resolver.authorize(),
  async (input) => {
-   const question = await db.question.create({data: input})
+   const question = await db.question.create({
+     data: {
+       ...input,
+       choix: {create: input.choix},
+     },
+   })

    return question
  },
)
```

Ensuite nous allons cr√©er un fichier s√©par√© o√π nous allons stocker la
schema de validation zod pour `QuestionForm`. Dans le r√©pertoire
`app/pages/questions`, cr√©ez un fichier nomm√© `validation.ts` et importez
`CreateQuestion` depuis `app/questions/mutations/createQuestion.ts`. Cr√©ez
une nouvelle variable nomm√©e `createQuestionSchema` et assignez-lui la
valeur de `CreateQuestion`. Vous pouvez maintenant l'exporter pour
l'utiliser dans le schema `QuestionForm` de la prochaine √©tape.

```diff
// app/pages/questions/validations.ts

+ import { CreateQuestion } from "app/questions/mutations/createQuestion"

+ export const createQuestionSchema = CreateQuestion
```

Naviguez vers `app/pages/questions/new.tsx` et importez
`createQuestionSchema` depuis `app/pages/questions/validations.ts` pour
l'utiliser en tant que schema de `QuestionForm`. Nous devons aussi ajouter
des valeurs par d√©faut `{{texte: "", choix: []}}` pour nos champs de
`QuestionForm`

```diff
// app/pages/questions/new.tsx

+ import {createQuestionSchema} from "app/pages/questions/validations"


      <QuestionForm
        submitText="Cr√©er une Question"
-       // TODO use a zod schema for form validation
-       //  - Tip: extract mutation's schema into a shared `validations.ts` file and
-       //         then import and use it here
-       // schema={createQuestion}
-       // initialValues={{ }}
+       schema={createQuestionSchema}
+       initialValues={{texte: "", choix: []}}
        onSubmit={async (values) => {
          try {
            const question = await createQuestionMutation(values)
            router.push(`/questions/${question.id}`)
          } catch (error) {
            console.error(error)
            return {
              [FORM_ERROR]: error.toString(),
            }
          }
        }}
      />
```

#### Essayez vos changements

Vous pouvez maintenant visiter `localhost:3000/questions/new` et cr√©er une
question √† choix multiples!

## Affichez les choix {#listing-choices}

Prenons une courte pause. Retournez √† `localhost:3000/questions` dans
votre navigateur et regardez toutes les questions que vous avez cr√©√©es.
Que diriez-vous de pouvoir lire tous les choix disponibles pour chaque
question au m√™me endroit? Premi√®rement vous devons personnaliser les
requ√™tes de questions. Avec Prisma, vous devez manuellement sp√©cifier
lorsque vous d√©sirez r√©cup√©rer une relation imbriqu√©e. Modifiez vos
fichiers `getQuestion.ts` et `getQuestions.ts` afin qu'ils ressemblent √†
ceci :

```diff
// app/questions/queries/getQuestion.ts

const GetQuestion = z.object({
  // Ceci accepte le type `undefined` √† la compilation, mais est bien requis
  id: z.number().optional().refine(Boolean, "Requis"),
})

export default resolver.pipe(
  resolver.zod(GetQuestion),
  resolver.authorize(),
  async ({id}) => {
-   const question = await db.question.findFirst({where: {id}})
+   const question = await db.question.findFirst({
+     where: {id},
+     include: {choix: true},
+   })

    if (!question) throw new NotFoundError()

    return question
  },
)
```

```diff
// app/questions/queries/getQuestions.ts

interface GetQuestionsInput
  extends Pick<
    Prisma.QuestionFindManyArgs,
    "where" | "orderBy" | "skip" | "take"
  > {}

export default resolver.pipe(
  resolver.authorize(),
  async ({where, orderBy, skip = 0, take = 100}: GetQuestionsInput) => {
    const {items: questions, hasMore, nextPage, count} = await paginate({
      skip,
      take,
      count: () => db.question.count({where}),
      query: (paginateArgs) =>
        db.question.findMany({
          ...paginateArgs,
          where,
          orderBy,
+         include: {choix: true},
        }),
    })

    return {
      questions,
      nextPage,
      hasMore,
      count,
    }
  },
)
```

Retournez √† la page de questions principale
(`app/pages/questions/index.tsx`) dans votre √©diteur. Nous pouvons
afficher la liste de choix de chaque question en ajoutant le code suivant
sous le composant `Link` dans `QuestionsList` :

```diff
// app/pages/questions/index.tsx

// ...
{
  questions.map((question) => (
    <li key={question.id}>
      <Link href={`/questions/${question.id}`}>
        <a>{question.texte}</a>
      </Link>
+     <ul>
+       {question.choix.map((choice) => (
+         <li key={choix.id}>
+           {choix.texte} - {choix.votes} votes
+         </li>
+       ))}
+     </ul>
    </li>
  ))
}
// ...
```

V√©rifiez le tout en visitant `/questions` avec votre navigateur.
**Magie!**

## Permettez aux utilisateurs de voter! {#let-people-vote-on-questions}

Naviguez vers `app/pages/questions/[questionId].tsx` dans votre √©diteur.
Pour commencer, nous allons am√©liorer cette page.

1. Remplacez `<h1>Question {question.id}</h1>` par
   `<h1>{question.texte}</h1>`.

2. Supprimez l'√©l√©ment `pre` et copiez la liste de choix que nous avons
   d√©finie auparavant :

```tsx
<ul>
  {question.choix.map((choix) => (
    <li key={choix.id}>
      {choix.texte} - {choix.votes} votes
    </li>
  ))}
</ul>
```

Si vous retournez dans votre navigateur, la page devrait maintenant
ressembler √† ceci!

<img
  width="567"
  alt="Screenshot"
  src="https://user-images.githubusercontent.com/24858006/80387990-3c3d8b80-88a1-11ea-956a-5be85f1e8f12.png"
/>

#### Il est temps de voter!

Premi√®rement nous devons ouvrir `app/choices/mutations/updateChoice.ts`,
modifier le schema zod et ajouter un incrementeur de votes.

```diff
const UpdateChoice = z
  .object({
    id: z.number(),
-   name: z.string(),
  })


export default resolver.pipe(
  resolver.zod(UpdateChoice),
  resolver.authorize(),
  async ({id, ...data}) => {
-   const choice = await db.choice.update({where: {id}, data})
+   const choice = await db.choice.update({
+     where: {id},
+     data: {votes: {increment: 1}},
+   })

    return choice
  },
)
```

Retournez √† `app/pages/questions/[questionId].tsx` et appliquez les
changements suivants :

Dans notre `li`, ajoutez un `button` comme ceci :

```tsx
<li key={choix.id}>
  {choix.texte} - {choix.votes} votes
  <button>Voter</button>
</li>
```

Ensuite, importez la mutation `updateChoice` que nous avons modifi√©e et
cr√©ez une fonction `handleVote` :

```diff
// app/pages/questions/[questionId].tsx
+import updateChoice from "app/choices/mutations/updateChoice"

//...

export const Question = () => {
  const router = useRouter()
  const questionId = useParam("questionId", "number")
  const [deleteQuestionMutation] = useMutation(deleteQuestion)
  const [question] = useQuery(getQuestion, {id: questionId})
+ const [updateChoiceMutation] = useMutation(updateChoice)
+
+ const handleVote = async (id: number) => {
+   try {
+     await updateChoiceMutation({id})
+     refetch()
+   } catch (error) {
+     alert("Error updating choice " + JSON.stringify(error, null, 2))
+   }
+ }

  return (
```

Par la suite nous devons modifier l'appel √† `useQuery` pour inclure la
fonction `refetch` que nous utilisons dans `handleVote`.

```diff
// app/pages/questions/[questionId].tsx

//...
- const [question] = useQuery(getQuestion, {id: questionId})
+ const [question, {refetch}] = useQuery(getQuestion, {id: questionId})
//...
```

Finalement, disons √† notre nouveau `button` d'ex√©cuter cette fonction!

```tsx
<button onClick={() => handleVote(choice.id)}>Voter</button>
```

Le composant `Question` devrait maintenant ressembler √† ceci :

```tsx
export const Question = () => {
  const router = useRouter()
  const questionId = useParam("questionId", "number")
  const [deleteQuestionMutation] = useMutation(deleteQuestion)
  const [question, { refetch }] = useQuery(getQuestion, {
    id: questionId,
  })
  const [updateChoiceMutation] = useMutation(updateChoice)

  const handleVote = async (id: number) => {
    try {
      await updateChoiceMutation({ id })
      refetch()
    } catch (error) {
      alert("Error updating choice " + JSON.stringify(error, null, 2))
    }
  }

  return (
    <>
      <Head>
        <title>Question {question.id}</title>
      </Head>

      <div>
        <h1>{question.texte}</h1>
        <ul>
          {question.choix.map((choix) => (
            <li key={choix.id}>
              {choix.texte} - {choix.votes} votes
              <button onClick={() => handleVote(choix.id)}>Voter</button>
            </li>
          ))}
        </ul>

        <Link href={`/questions/${question.id}/edit`}>
          <a>Modifier</a>
        </Link>

        <button
          type="button"
          onClick={async () => {
            if (window.confirm("Cette question sera supprim√©e")) {
              await deleteQuestionMutation({ id: question.id })
              router.push("/questions")
            }
          }}
          style={{ marginLeft: "0.5rem" }}
        >
          Supprimer
        </button>
      </div>
    </>
  )
}
```

## Finalement, ajoutons la possibilit√© de modifier les choix d'une question {#edit-choices-for-question}

Si vous cliquez sur le boutton **Modifier** sur la page d'une question
existante, vous verrez que le formulaire est le m√™me que pour la cr√©ation.
Cette partie est donc d√©j√† faite pour nous, il ne reste qu'a modifier
notre mutation.

Ouvrez `app/questions/mutations/updateQuestion.ts` et appliquez les
changements suivants :

```diff
// app/questions/mutations/updateQuestion.ts
import {resolver} from "blitz"
import db from "db"
import * as z from "zod"

const UpdateQuestion = z
  .object({
    id: z.number(),
    texte: z.string(),
+   choix: z.array(
+     z.object({id: z.number().optional(), texte: z.string()}),
+   ),
  })

export default resolver.pipe(
  resolver.zod(UpdateQuestion),
  resolver.authorize(),
  async ({id, ...data}) => {
-   const question = await db.question.update({where: {id}, data})
+   const question = await db.question.update({
+     where: {id},
+     data: {
+       ...data,
+       choix: {
+         upsert: data.choix.map((choix) => ({
+           // Il s'agit d'un bogue Prisma,
+           // puisque `|| 0` ne devrait pas √™tre n√©cessaire
+           where: {id: choix.id || 0},
+           create: {text: choix.texte},
+           update: {text: choix.texte},
+         })),
+       },
+     },
+     include: {
+       choix: true,
+     },
+   })

    return question
  },
)
```

[`upsert`](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#upsert)
est une op√©ration sp√©ciale qui pourrait se r√©sumer en "Si cet √©l√©ment
existe d√©j√†, modifiez le. Sinon cr√©ez le". C'est parfait pour notre cas de
figure puisque nous n'obligeons pas l'utilisateur √† ajouter trois choix
d√®s le d√©part. Si on veut en ajouter plus tard en modifiant la question,
c'est ici qu'ils seront cr√©√©s.

## Faites le m√©nage {#cleanup}

Afin que la commande `yarn tsc` ou `git push` s'ex√©cute sans erreur, vous
devez supprimer `app/choices/mutations/createChoice.ts` (non utilis√©) ou
modifier le schema zod `CreateChoice` afin qu'il inclue les champs requis.

## Conclusion {#conclusion}

ü•≥ F√©licitations! Vous avez cr√©√© votre propre application Blitz!
Amusez-vous √† l'explorer ou √† la partager avec vos amis. Maintenant que
vous avez compl√©t√© ce tutoriel, pourquoi ne pas essayer d'am√©liorer encore
plus votre application de votes? Voici quelques suggestions :

- Ajouter du style (essayez `blitz install tailwind` ou
  `blitz install chakra-ui`)
- Afficher plus de statistiques √† propos des votes
- D√©ployer une version publique avec [Render](./deploy-render) ou
  [Vercel](./deploy-vercel)

Si vous voulez partager votre projet avec la communaut√© internationale de
Blitz, vous ne trouverez pas de meilleur endroit que Discord.

Visitez [discord.blitzjs.com](https://discord.blitzjs.com) et partagez le
lien avec les autres membres dans le canal **#built-with-blitz**!
