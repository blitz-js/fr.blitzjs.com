---
title: Tutoriel
sidebar_label: Tutoriel
---

Dans ce tutoriel, nous allons vous apprendre Ã  crÃ©er use simple
application de vote.

Ce guide suppose que vous avez dÃ©jÃ  [installÃ© Blitz](./get-started). Vous
pouvez vÃ©rifier si c'est le cas ainsi que quelle version vous avez en
exÃ©cutant la commande suivante dans votre terminal :

```sh
blitz -v
```

Si Blitz est bien installÃ©, vous devriez voir le numÃ©ro de la version de
votre installation. Sinon il ne l'est pas, vous devriez voir une erreur
comme "command not found: blitz".

## CrÃ©ez une nouvelle application {#creating-a-new-app}

Depuis le terminal, dÃ©placez-vous dans le rÃ©pertoire oÃ¹ vous souhaitez
crÃ©er votre application en utilisant la commande `cd`. Ensuite, exÃ©cutez
la commande suivante :

```sh
blitz new mon-appli-blitz
```

Blitz s'occupera de crÃ©er un dossier `mon-appli-blitz` dans le rÃ©pertoire.
Il vous sera Ã©galement demandÃ© de choisir un module de gestion de
formulaire. Pour les exemples suivant, choisissez le module recommandÃ©
`React Final Form`.

Jettons un oeil Ã  ce que `blitz new` a crÃ©Ã© :

```
mon-appli-blitz/
â”œâ”€â”€ app/
â”‚Â Â  â”œâ”€â”€ api/
â”‚Â Â  â”œâ”€â”€ auth/
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ components/
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ LoginForm.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ SignupForm.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ mutations/
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ changePassword.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ forgotPassword.test.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ forgotPassword.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ login.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ logout.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ resetPassword.test.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ resetPassword.ts
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ signup.ts
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ pages/
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ forgot-password.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ login.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ reset-password.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ signup.tsx
â”‚Â Â  â”‚Â Â  â””â”€â”€ validations.ts
â”‚Â Â  â”œâ”€â”€ core/
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ components/
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ Form.tsx
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ LabeledTextField.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ hooks/
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ useCurrentUser.ts
â”‚Â Â  â”‚Â Â  â””â”€â”€ layouts/
â”‚Â Â  â”‚Â Â      â””â”€â”€ Layout.tsx
â”‚Â Â  â”œâ”€â”€ pages/
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ 404.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ _app.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ _document.tsx
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ index.test.tsx
â”‚Â Â  â”‚Â Â  â””â”€â”€ index.tsx
â”‚Â Â  â””â”€â”€ users/
â”‚Â Â      â””â”€â”€ queries/
â”‚Â Â          â””â”€â”€ getCurrentUser.ts
â”œâ”€â”€ db/
â”‚Â Â  â”œâ”€â”€ index.ts
â”‚Â Â  â”œâ”€â”€ schema.prisma
â”‚Â Â  â””â”€â”€ seeds.ts
â”œâ”€â”€ integrations/
â”œâ”€â”€ mailers/
â”‚Â Â  â””â”€â”€ forgotPasswordMailer.ts
â”œâ”€â”€ public/
â”‚Â Â  â”œâ”€â”€ favicon.ico*
â”‚Â Â  â””â”€â”€ logo.png
â”œâ”€â”€ test/
â”‚Â Â  â”œâ”€â”€ setup.ts
â”‚Â Â  â””â”€â”€ utils.tsx
â”œâ”€â”€ README.md
â”œâ”€â”€ babel.config.js
â”œâ”€â”€ blitz.config.js
â”œâ”€â”€ jest.config.js
â”œâ”€â”€ package.json
â”œâ”€â”€ tsconfig.json
â”œâ”€â”€ types.d.ts
â”œâ”€â”€ types.ts
â””â”€â”€ yarn.lock
```

Ces fichiers sont :

- Le rÃ©pertoire `app/` contient la majoritÃ© de votre projet. C'est ici que
  vous ajouterez vos pages et routes d'API.

- Le rÃ©pertoire `app/pages/` est le principal endroit ou vous crÃ©erez vos
  pages. Si vous avez dÃ©jÃ  utilisÃ© Next.js, vous remarquerez immÃ©diatement
  la diffÃ©rence. Avec Blitz, vous pouvez avoir plusieurs rÃ©pertoires
  `pages` qui seront combinÃ©s au moment de la compilation.

- Le rÃ©pertoire `app/core/` est l'endroit parfait pour stocker vos
  composants, hooks et autre code rÃ©utilisable Ã  travers votre
  application.

- Le rÃ©pertoire `db/` contient la configuration de votre base de donnÃ©es.
  Si vous voulez crÃ©er un nouveau modÃ¨le ou lancer une migration, c'est
  ici que vous trouverez ce qu'il vous faut.

- Le rÃ©pertoire `public/` contient toutes vos resources statiques. Si
  votre application nÃ©cÃ©ssite des images, documents ou vidÃ©os, c'est ici
  que vous devriez les stocker.

- Les fichiers `.babelrc.js`, `.env`, etc. aussi connus sous le nom de
  "dotfiles", sont des fichiers de configuration pour diffÃ©rents outils
  JavaScript.

- `blitz.config.js` offre aux utilisateurs avancÃ©s la possibilitÃ© de
  personnaliser leur installation de Blitz. Il supporte le mÃªme format que
  `next.config.js`.

- `tsconfig.json` contient nos rÃ¨gles de configuration prÃ©fÃ©rÃ©es pour le
  compilateur TypeScript.

## DÃ©marrez le serveur de dÃ©veloppement {#the-development-server}

Assurez-vous d'Ãªtre dans le rÃ©pertoire `mon-appli-blitz` avant d'exÃ©cuter
la commande suivante :

```sh
blitz dev
```

Vous devriez voir le message suivant dans votre terminal :

```sh
âœ” Compiled
Loaded env from /private/tmp/mon-appli-blitz/.env
warn  - You have enabled experimental feature(s).
warn  - Experimental features are not covered by semver, and may cause unexpected or broken application behavior. Use them at your own risk.

ready - started server on 0.0.0.0:3000, url: http://localhost:3000
info  - Using external babel configuration from /mon-appli-blitz/babel.config.js
event - compiled successfully
```

Maintenant que le serveur est dÃ©marrÃ©, visitez
[localhost:3000](http://localhost:3000) avec votre navigateur web. Vous
verrez une page de bienvenue avec le logo Blitz. Tout fonctionne!

## CrÃ©ez un compte utilisateur {#sign-up-as-a-user}

Les applications Blitz comprennent un systÃ¨me de gestion d'utilisateurs
par dÃ©faut, essayons le! Cliquez sur le bouton **Sign Up**. Entrez
n'importe quelle adresse email et mot de passe et cliquez sur **Create
Account**. Vous serez ensuite redirigÃ© vers la page d'acceuil oÃ¹ vous
pourrez apercevoir votre `id` et votre `role`.

Si vous le dÃ©sirez, vous pouvez Ã©galement essayer de vous dÃ©connecter et
vous connecter de nouveau. N'hÃ©sitez pas Ã  cliquer sur **Forgot your
password?** pour rÃ©initialiser votre mot de passe.

## Construisez votre premiÃ¨re page {#write-your-first-page}

Ouvrez le fichier `app/pages/index.tsx` et remplacez le contenu du
composant `Home` par ceci :

```tsx
//...

const Home: BlitzPage = () => {
  return (
    <div>
      <h1>Bonjour, Blitz!</h1>

      <Suspense fallback="Chargement...">
        <UserInfo />
      </Suspense>
    </div>
  )
}

//...
```

Sauvegardez vos changements et vous devriez voir la page se mettre Ã  jour
dans votre navigateur web. Vous pouvez personnaliser ce composant autant
que vous le souhaitez. Lorsque vous serez prÃªtÂ·e, passez Ã  la prochaine
section.

## Configurez une base de donnÃ©es {#database-setup}

Bonne nouvelle! Une base de donnÃ©es SQLite est dÃ©jÃ  configurÃ©e! Vous
pouvez exÃ©cuter `blitz prisma studio` dans votre terminal pour explorer
vos tables et leurs champs via une interface web.

Veuillez notez que dans le contexte d'un vrai projet, vous auriez avantage
Ã  utiliser une base de donnÃ©es plus robuste, telle que PostgreSQL, dÃ¨s le
dÃ©part afin d'Ã©viter de devoir changer plus tard. Pour plus
d'informations, visitez notre
[guide de base de donnÃ©es](database-overview). Pour ce tutoriel, nous
allons continuer avec SQLite.

## GÃ©nÃ©rez le code de vos modÃ¨les {#scaffolding-code-for-our-models}

Blitz vous permet de gÃ©nÃ©rer le code nÃ©cÃ©ssaire pour une multitude de
situations via la commande [`generate`](./cli-generate). Nous allons
l'utiliser afin de gÃ©nÃ©rer deux modÃ¨les : `Question` et `Choice`. Une
`Question` consiste du texte de la question ainsi qu'une liste de choix de
rÃ©ponse. Un `Choice` contient le texte du choice, un nombre de votes et la
question Ã  laquelle il fait rÃ©fÃ©rence. Blitz s'occupe de gÃ©nÃ©rer un `id`
unique, la date de crÃ©ation ainsi que la date de la derniÃ¨re modification
pour chacun des modÃ¨le.

#### PremiÃ¨rement, nous allons gÃ©nÃ©rer le modÃ¨le `Question` :

```sh
blitz generate all question texte:string
```

Lorsque demandÃ©, appuyez sur la touche **EntrÃ©e** afin d'exÃ©cuter
`prisma migrate` pour mettre votre schema de base de donnÃ©es Ã  jour avec
le modÃ¨le nouvellement crÃ©Ã©. Vous devrez entrer un nom pour cette
migration, par exemple : "ajout question".

```
CREATE    app/pages/questions/[questionId].tsx
CREATE    app/pages/questions/[questionId]/edit.tsx
CREATE    app/pages/questions/index.tsx
CREATE    app/pages/questions/new.tsx
âœ” Compiled
CREATE    app/questions/components/QuestionForm.tsx
CREATE    app/questions/queries/getQuestion.ts
CREATE    app/questions/queries/getQuestions.ts
CREATE    app/questions/mutations/createQuestion.ts
CREATE    app/questions/mutations/deleteQuestion.ts
CREATE    app/questions/mutations/updateQuestion.ts

âœ” Model 'Question' created in schema.prisma:

>
> model Question {
>   id        Int      @id @default(autoincrement())
>   createdAt DateTime @default(now())
>   updatedAt DateTime @updatedAt
>   texte      String
> }
>

âœ” Run 'prisma migrate dev' to update your database? (Y/n) Â· true
Environment variables loaded from .env
Prisma schema loaded from db/schema.prisma
Datasource "db": SQLite database "db.sqlite" at "file:./db.sqlite"

âœ” Enter a name for the new migration: â€¦ ajout question
The following migration(s) have been created and applied from new schema changes:

migrations/
  â””â”€ 20210722070215_ajout_question/
    â””â”€ migration.sql

Your database is now in sync with your schema.

âœ” Generated Prisma Client (2.27.0) to ./node_modules/@prisma/client in 187ms
```

Lorsque suivie par l'option `all`, la commande `generate` gÃ©nÃ¨re un modÃ¨le
ainsi que toutes ses requÃªtes, mutations et pages. Pour une liste
d'options complÃ¨te, visitez [Blitz generate](./cli-generate).

#### Ensuite gÃ©nÃ©rÃ©z le modÃ¨le `Choice` avec ses requÃªtes et mutations.

Cette fois, nous allons utiliser l'option `resource` puisque nous ne
voulons pas gÃ©nÃ©rer de pages pour le modÃ¨le `Choice`:

```sh
blitz generate resource choice texte votes:int:default=0 belongsTo:question
```

Si vous obtenez une erreur, exÃ©cutez `blitz prisma format`

Veuillez noter que ceci ne requiert pas de migration puisque nous n'avons
pas encore ajoutÃ© le champ `Choix` au modÃ¨le `Question`. Nous allons donc
choisir `false` lorsqu'on nous demandera de dÃ©marrer une migration :

```
CREATE    app/choices/queries/getChoice.ts
CREATE    app/choices/queries/getChoices.ts
CREATE    app/choices/mutations/createChoice.ts
CREATE    app/choices/mutations/deleteChoice.ts
CREATE    app/choices/mutations/updateChoice.ts

âœ” Model for 'choice' created in schema.prisma:

> model Choice {
>   id         Int      @default(autoincrement()) @id
>   createdAt  DateTime @default(now())
>   updatedAt  DateTime @updatedAt
>   texte       String
>   votes      Int      @default(0)
>   question   Question @relation(fields: [questionId], references: [id])
>   questionId Int
> }

? Run 'prisma migrate dev' to update your database? (Y/n) â€º false
```

#### Finalement, ajouter Ã  `Question` un relation vers `Choice`.

Ouvrez `db/schema.prisma` et ajoutez `choix Choice[]` au modÃ¨le
`Question`.

```diff
model Question {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  texte     String
+ choix     Choice[]
}
```

Nous pouvons dÃ©sormais dÃ©marrer la migration pour mettre Ã  jour notre base
de donnÃ©es :

```sh
blitz prisma migrate dev
```

Encore une fois, choisissez un nom pour la migration, par exemple : "ajout
choice".

```
Environment variables loaded from .env
Prisma schema loaded from db/schema.prisma
Datasource "db": SQLite database "db.sqlite" at "file:./db.sqlite"

âœ” Name of migration â€¦ ajout choice
The following migration(s) have been created and applied from new schema changes:

migrations/
  â””â”€ 20210412175528_ajout_choice/
    â””â”€ migration.sql

Your database is now in sync with your schema.
```

Notre base de donnÃ©es est maintenant prÃªte Ã  Ãªtre utilisÃ©e et un client
Prisma a Ã©galement Ã©tÃ© gÃ©nÃ©rÃ© pour nous. Allons l'essayer!

## Playing with the Prisma database client {#playing-with-the-prisma-database-client}

Now, letâ€™s hop into the interactive Blitz shell and play around with the
Prisma database client that Blitz gives you. To start the Blitz console,
use this command:

```sh
blitz console
```

Once youâ€™re in the console, explore the database client:

```sh
# No questions are in the system yet.
âš¡ > await db.question.findMany()
[]

# Create a new Question:
âš¡ > let q = await db.question.create({data: {text: "What's new?"}})
undefined

# See the entire object:
âš¡ > q
{
  id: 1,
  createdAt: 2020-06-15T15:06:14.959Z,
  updatedAt: 2020-06-15T15:06:14.959Z,
  text: "What's new?"
}

# Or, access individual values on the object:
âš¡ > q.text
"What's new?"

# Change values by using the update function:
âš¡ > q = await db.question.update({where: {id: 1}, data: {text: "What's up?"}})
{
  id: 1,
  createdAt: 2020-06-15T15:06:14.959Z,
  updatedAt: 2020-06-15T15:13:17.394Z,
  text: "What's up?"
}

# db.question.findMany() now displays all the questions in the database:
âš¡ > await db.question.findMany()
[
  {
    id: 1,
    createdAt: 2020-06-15T15:06:14.959Z,
    updatedAt: 2020-06-15T15:13:17.394Z,
    text: "What's up?"
  }
]
```

## Update generated code for our model attributes {#update-generated-code-for-our-model-attributes}

<Card type="info">

Before running the app again, we need to customize some of the code that
has been generated. Ultimately, these fixes will not be needed - but for
now, we need to work around a couple outstanding issues.

</Card>

The generated page content does not currently use the actual model
attributes you defined during generation. It will soon, but in the
meantime, let's fix the generated pages.

### Question pages {#question-pages}

[//]:
  #
  "Remove the following section once `generate` uses actual model attributes"

Jump over to `app/pages/questions/index.tsx`. Notice that a
`QuestionsList` component has been generated for you:

```tsx
// app/pages/questions/index.tsx

export const QuestionsList = () => {
  const router = useRouter()
  const page = Number(router.query.page) || 0
  const [{ questions, hasMore }, { isPreviousData }] = usePaginatedQuery(
    getQuestions,
    {
      orderBy: { id: "asc" },
      skip: ITEMS_PER_PAGE * page,
      take: ITEMS_PER_PAGE,
    }
  )

  const goToPreviousPage = () =>
    router.push({ query: { page: page - 1 } })

  const goToNextPage = () => {
    if (!isPreviousData && hasMore) {
      router.push({ query: { page: page + 1 } })
    }
  }

  return (
    <div>
      <ul>
        {questions.map((question) => (
          <li key={question.id}>
            <Link href={`/questions/${question.id}`}>
              <a>{question.name}</a>
            </Link>
          </li>
        ))}
      </ul>

      <button disabled={page === 0} onClick={goToPreviousPage}>
        Previous
      </button>
      <button
        disabled={isPreviousData || !hasMore}
        onClick={goToNextPage}
      >
        Next
      </button>
    </div>
  )
}
```

This wonâ€™t work though! Remember that the `Question` model we created
above doesnâ€™t have any `name` field. To fix this, replace `question.name`
with `question.text`:

```diff
// app/pages/questions/index.tsx

export const QuestionsList = () => {
  const router = useRouter()
  const page = Number(router.query.page) || 0
  const [{questions, hasMore}, {isPreviousData}] = usePaginatedQuery(
    getQuestions, {
      orderBy: {id: "asc"},
      skip: ITEMS_PER_PAGE * page,
      take: ITEMS_PER_PAGE,
    },
  )

  const goToPreviousPage = () => router.push({query: {page: page - 1}})

  const goToNextPage = () => {
    if (!isPreviousData && hasMore) {
      router.push({query: {page: page + 1}})
    }
  }

  return (
    <div>
      <ul>
        {questions.map((question) => (
          <li key={question.id}>
            <Link href={`/questions/${question.id}`}>
-              <a>{question.name}</a>
+              <a>{question.text}</a>
            </Link>
          </li>
        ))}
      </ul>

      <button disabled={page === 0} onClick={goToPreviousPage}>
        Previous
      </button>
      <button disabled={isPreviousData || !hasMore} onClick={goToNextPage}>
        Next
      </button>
    </div>
  )
}
```

Next, letâ€™s apply a similar fix to
`app/questions/components/QuestionForm.tsx`. In the form submission,
replace the `LabeledTextField` `name` to be `"text"`

```diff
export function QuestionForm<S extends z.ZodType<any, any>>(
  props: FormProps<S>,
) {
  return (
    <Form<S> {...props}>
-     <LabeledTextField name="name" label="Name" placeholder="Name" />
+     <LabeledTextField name="text" label="Text" placeholder="Text" />
    </Form>
  )
}
```

### `createQuestion` mutation {#create-question-mutation}

In `app/questions/mutations/createQuestion.ts`, we need to update the
`CreateQuestion` zod validation schema to use `text` instead of `name`.

```diff
// app/questions/mutations/createQuestion.ts

const CreateQuestion = z
  .object({
-   name: z.string(),
+   text: z.string(),
  })
// ...
```

### `updateQuestion` mutation {#update-question-mutation}

In `app/questions/mutations/updateQuestion.ts`, we need to update the
`UpdateQuestion` zod validation schema to use `text` instead of `name`.

```diff
// app/questions/mutations/updateQuestion.ts

const UpdateQuestion = z
  .object({
    id: z.number(),
-   name: z.string(),
+   text: z.string(),
  })
```

### `deleteQuestion` mutation {#delete-question-mutation}

[//]: # "Remove this section once Prisma supports cascading deletes"

Prisma does not yet support "cascading deletes". In the context of this
tutorial, that means it does not currently delete the `Choice` data when
deleting a `Question`. We need to temporarily augment the generated
`deleteQuestion` mutation in order to do this manually. Open up
`app/questions/mutations/deleteQuestion.ts` in your text editor and add
the following to the top of the function body:

```ts
await db.choice.deleteMany({ where: { questionId: id } })
```

The end result should be as such:

```diff
// app/questions/mutations/deleteQuestion.ts

export default resolver.pipe(
  resolver.zod(DeleteQuestion),
  resolver.authorize(),
  async ({id}) => {
+   await db.choice.deleteMany({where: {questionId: id}})
    const question = await db.question.deleteMany({where: {id}})

    return question
  },
)
```

This mutation will now delete the choices associated with the question
prior to deleting the question itself.

#### Now try creating, updating, and deleting questions

Great! Now make sure your app is running. If it isnâ€™t, run `blitz dev` in
your terminal, and visit `localhost:3000/questions`. Try creating
questions, editing, and deleting them.

## Adding choices to the question form {#adding-choices-to-the-question-form}

Youâ€™re doing great so far! The next thing weâ€™ll do is add choices to our
question form. Open `app/questions/components/QuestionForm.tsx` in your
editor.

Add three more `<LabeledTextField>` components as choices.

```diff
export function QuestionForm<S extends z.ZodType<any, any>>(
  props: FormProps<S>,
) {
  return (
    <Form<S> {...props}>
      <LabeledTextField name="text" label="Text" placeholder="Text" />
+     <LabeledTextField name="choices.0.text" label="Choice 1" />
+     <LabeledTextField name="choices.1.text" label="Choice 2" />
+     <LabeledTextField name="choices.2.text" label="Choice 3" />
    </Form>
  )
}
```

Now open `app/questions/mutations/createQuestion.ts` and update the zod
schema so that the choice data is accepted in the mutation. We also need
to update the `db.question.create()` call so that the choices will be
created. After that we need to export the `CreateQuestion` zod schema
because we will be using it in the next step to create a validation schema
for our `QuestionForm`.

```diff
// app/questions/mutations/createQuestion.ts

+ export const CreateQuestion = z
    .object({
      text: z.string().nonempty({message: "You must enter a question."}),
+     choices: z.array(z.object({text: z.string()})),
    })

export default resolver.pipe(
  resolver.zod(CreateQuestion),
  resolver.authorize(),
  async (input) => {
-   const question = await db.question.create({data: input})
+   const question = await db.question.create({
+     data: {
+       ...input,
+       choices: {create: input.choices},
+     },
+   })

    return question
  },
)
```

Next we're going to create a separate file to store the validation schema
for our `QuestionForm`. In the `app/pages/questions` folder create a new
file called `validations.ts` and import `CreateQuestion` from
`app/questions/mutations/createQuestion.ts`. Then create a new variable
called `createQuestionSchema`, set it equal to `CreateQuestion`, and
export it so we can use it for our `QuestionForm` schema in the next step.

```diff
// app/pages/questions/validations.ts

+ import { CreateQuestion } from "app/questions/mutations/createQuestion"

+ export const createQuestionSchema = CreateQuestion
```

Now open `app/pages/questions/new.tsx` and import `createQuestionSchema`
from `app/pages/questions/validations.ts` and set it as the schema for
`QuestionForm`. Also, we need set `{{text: "", choices: []}}` as our
`initialValues` for `QuestionForm`:

```diff
// app/pages/questions/new.tsx

+ import {createQuestionSchema} from "app/pages/questions/validations"


      <QuestionForm
        submitText="Create Question"
-       // TODO use a zod schema for form validation
-       //  - Tip: extract mutation's schema into a shared `validations.ts` file and
-       //         then import and use it here
-       // schema={createQuestion}
-       // initialValues={{ }}
+       schema={createQuestionSchema}
+       initialValues={{text: "", choices: []}}
        onSubmit={async (values) => {
          try {
            const question = await createQuestionMutation(values)
            router.push(`/questions/${question.id}`)
          } catch (error) {
            console.error(error)
            return {
              [FORM_ERROR]: error.toString(),
            }
          }
        }}
      />
```

#### Try it out

Now you can go to `localhost:3000/questions/new` and create a new question
with choices!

## Listing choices {#listing-choices}

Time for a breather. Go back to `localhost:3000/questions` in your browser
and look at all the questions youâ€˜ve created. How about we list these
questionsâ€™ choices here too? First, we need to customize the question
queries. In Prisma, you need to manually let the client know that you want
to query for nested relations. Change your `getQuestion.ts` and
`getQuestions.ts` files to look like this:

```diff
// app/questions/queries/getQuestion.ts

const GetQuestion = z.object({
  // This accepts type of undefined, but is required at runtime
  id: z.number().optional().refine(Boolean, "Required"),
})

export default resolver.pipe(
  resolver.zod(GetQuestion),
  resolver.authorize(),
  async ({id}) => {
-   const question = await db.question.findFirst({where: {id}})
+   const question = await db.question.findFirst({
+     where: {id},
+     include: {choices: true},
+   })

    if (!question) throw new NotFoundError()

    return question
  },
)
```

```diff
// app/questions/queries/getQuestions.ts

interface GetQuestionsInput
  extends Pick<
    Prisma.QuestionFindManyArgs,
    "where" | "orderBy" | "skip" | "take"
  > {}

export default resolver.pipe(
  resolver.authorize(),
  async ({where, orderBy, skip = 0, take = 100}: GetQuestionsInput) => {
    const {items: questions, hasMore, nextPage, count} = await paginate({
      skip,
      take,
      count: () => db.question.count({where}),
      query: (paginateArgs) =>
        db.question.findMany({
          ...paginateArgs,
          where,
          orderBy,
+         include: {choices: true},
        }),
    })

    return {
      questions,
      nextPage,
      hasMore,
      count,
    }
  },
)
```

Now hop back to our main questions page
(`app/pages/questions/index.tsx`)in your editor, and we can list the
choices of each question. And add this code beneath the `Link` in our
`QuestionsList`:

```diff
// app/pages/questions/index.tsx

// ...
{
  questions.map((question) => (
    <li key={question.id}>
      <Link href={`/questions/${question.id}`}>
        <a>{question.text}</a>
      </Link>
+     <ul>
+       {question.choices.map((choice) => (
+         <li key={choice.id}>
+           {choice.text} - {choice.votes} votes
+         </li>
+       ))}
+     </ul>
    </li>
  ))
}
// ...
```

Now check `/questions` in the browser. **Magic!**

## Letâ€™s let people vote on these questions! {#let-people-vote-on-questions}

Open `app/pages/questions/[questionId].tsx` in your editor. First, weâ€™re
going to improve this page somewhat.

1. Replace `<h1>Question {question.id}</h1>` with
   `<h1>{question.text}</h1>`.

2. Delete the `pre` element, and copy in our choices list which we wrote
   before:

```tsx
<ul>
  {question.choices.map((choice) => (
    <li key={choice.id}>
      {choice.text} - {choice.votes} votes
    </li>
  ))}
</ul>
```

If you go back to your browser, your page should now look something like
this!

<img
  width="567"
  alt="Screenshot"
  src="https://user-images.githubusercontent.com/24858006/80387990-3c3d8b80-88a1-11ea-956a-5be85f1e8f12.png"
/>

#### Now itâ€™s time to add voting!

First we need to open `app/choices/mutations/updateChoice.ts`, update the
zod schema, and add a vote increment.

```diff
const UpdateChoice = z
  .object({
    id: z.number(),
-   name: z.string(),
  })


export default resolver.pipe(
  resolver.zod(UpdateChoice),
  resolver.authorize(),
  async ({id, ...data}) => {
-   const choice = await db.choice.update({where: {id}, data})
+   const choice = await db.choice.update({
+     where: {id},
+     data: {votes: {increment: 1}},
+   })

    return choice
  },
)
```

Now go back to `app/pages/questions/[questionId].tsx` and make the
following changes:

In our `li`, add a `button` like so:

```tsx
<li key={choice.id}>
  {choice.text} - {choice.votes} votes
  <button>Vote</button>
</li>
```

Then, import the `updateChoice` mutation we updated and create a
`handleVote` function in our page:

```diff
// app/pages/questions/[questionId].tsx
+import updateChoice from "app/choices/mutations/updateChoice"

//...

export const Question = () => {
  const router = useRouter()
  const questionId = useParam("questionId", "number")
  const [deleteQuestionMutation] = useMutation(deleteQuestion)
  const [question] = useQuery(getQuestion, {id: questionId})
+ const [updateChoiceMutation] = useMutation(updateChoice)
+
+ const handleVote = async (id: number) => {
+   try {
+     await updateChoiceMutation({id})
+     refetch()
+   } catch (error) {
+     alert("Error updating choice " + JSON.stringify(error, null, 2))
+   }
+ }

  return (
```

And then we need to update the question `useQuery` call to return the
`refetch` function which we use inside `handleVote`:

```diff
// app/pages/questions/[questionId].tsx

//...
- const [question] = useQuery(getQuestion, {id: questionId})
+ const [question, {refetch}] = useQuery(getQuestion, {id: questionId})
//...
```

Finally, weâ€™ll tell our new `button` to call that function!

```tsx
<button onClick={() => handleVote(choice.id)}>Vote</button>
```

The final `Question` component should now look like this:

```tsx
export const Question = () => {
  const router = useRouter()
  const questionId = useParam("questionId", "number")
  const [deleteQuestionMutation] = useMutation(deleteQuestion)
  const [question, { refetch }] = useQuery(getQuestion, {
    id: questionId,
  })
  const [updateChoiceMutation] = useMutation(updateChoice)

  const handleVote = async (id: number) => {
    try {
      await updateChoiceMutation({ id })
      refetch()
    } catch (error) {
      alert("Error updating choice " + JSON.stringify(error, null, 2))
    }
  }

  return (
    <>
      <Head>
        <title>Question {question.id}</title>
      </Head>

      <div>
        <h1>{question.text}</h1>
        <ul>
          {question.choices.map((choice) => (
            <li key={choice.id}>
              {choice.text} - {choice.votes} votes
              <button onClick={() => handleVote(choice.id)}>Vote</button>
            </li>
          ))}
        </ul>

        <Link href={`/questions/${question.id}/edit`}>
          <a>Edit</a>
        </Link>

        <button
          type="button"
          onClick={async () => {
            if (window.confirm("This will be deleted")) {
              await deleteQuestionMutation({ id: question.id })
              router.push("/questions")
            }
          }}
          style={{ marginLeft: "0.5rem" }}
        >
          Delete
        </button>
      </div>
    </>
  )
}
```

## Lastly, let's allow editing choices for an existing question {#edit-choices-for-question}

If you click the **Edit** button on one of your existing questions, you'll
see it uses the same form as creating questions. So that part is already
done! We only need to update our mutation.

Open `app/questions/mutations/updateQuestion.ts` and make the following
changes:

```diff
// app/questions/mutations/updateQuestion.ts
import {resolver} from "blitz"
import db from "db"
import * as z from "zod"

const UpdateQuestion = z
  .object({
    id: z.number(),
    text: z.string(),
+   choices: z.array(
+     z.object({id: z.number().optional(), text: z.string()}),
+   ),
  })

export default resolver.pipe(
  resolver.zod(UpdateQuestion),
  resolver.authorize(),
  async ({id, ...data}) => {
-   const question = await db.question.update({where: {id}, data})
+   const question = await db.question.update({
+     where: {id},
+     data: {
+       ...data,
+       choices: {
+         upsert: data.choices.map((choice) => ({
+           // Appears to be a prisma bug,
+           // because `|| 0` shouldn't be needed
+           where: {id: choice.id || 0},
+           create: {text: choice.text},
+           update: {text: choice.text},
+         })),
+       },
+     },
+     include: {
+       choices: true,
+     },
+   })

    return question
  },
)
```

[`upsert`](https://www.prisma.io/docs/reference/api-reference/prisma-client-reference#upsert)
is a special operation that means, "If this item exists, update it. Else
create it". This is perfect for this case because we didn't require the
user to add three choices when creating the question. So if later the user
adds another choice by editing the question, then it'll be created here.

## Cleanup {#cleanup}

In order for `yarn tsc` or `git push` to succeed, you'll need to delete
`app/choices/mutations/createChoice.ts` (unused) or update the
CreateChoice zod schema to include the required fields.

## Conclusion {#conclusion}

ðŸ¥³ Congrats! You created your very own Blitz app! Have fun playing around
with it, or sharing it with your friends. Now that youâ€™ve finished this
tutorial, why not try making your voting app even better? You could try:

- Adding styling (Hint, try `blitz install tailwind` or
  `blitz install chakra-ui`)
- Showing some more statistics about votes
- Deploying live on [Render](./deploy-render) or [Vercel](./deploy-vercel)

If you want to share your project with the world wide Blitz community
there is no better place to do that than on Discord.

Visit [discord.blitzjs.com](https://discord.blitzjs.com). Then, post the
link to the **#built-with-blitz** channel to share it with everyone!
